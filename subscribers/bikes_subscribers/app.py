from typing import Optional, List, Tuple
from kafka import KafkaConsumer
import json
import time

# --- Op√≥≈∫nienie startu ---
# print("Kontener startuje")
# time.sleep(180)

# --- Importy po≈ÇƒÖczenia siƒô i funkcji ≈ÇƒÖczƒÖcych siƒô z PostGreSQL i innych ---
from shared.db_utils import save_log, save_bike_data_to_base, get_model_status, update_model_new_available_flag
from shared.preprocessing_utils import enrich_data_with_environment, rename_keys, replace_nulls, create_bike_summary_sentence, prepare_sql_record_all_fields, prepare_vector_db_record_all_bike_fields
from shared.clusterization.clusterization import bike_cluster_predictor
from shared.classification.classification import bike_binary_predictor, bike_multiclass_predictor, bike_regression_predictor
from shared.anything_wrapper import add_raw_bike_text_to_anythingllm

# --- Ustawienia podstawowe ---
KAFKA_BROKER = "kafka-broker-1:9092"
KAFKA_TOPIC = "bikes"
KAFKA_GROUP = "bikes-subscriber"  
ANYTHINGLLM_WORKSPACE_SLUG = "project"
CLUSTER_MODEL_NAME = "bikes_kmeans"
CLASS_MODEL_A = "bikes_binary_classifier"
CLASS_MODEL_B = "bikes_multiclass_classifier"
CLASS_MODEL_C = "bikes_regression_predictor"

# --- Ustawienie Kafka Subscriber ---
consumer = KafkaConsumer(
    KAFKA_TOPIC,
    bootstrap_servers=KAFKA_BROKER,
    auto_offset_reset='earliest',
    enable_auto_commit=True,
    group_id=KAFKA_GROUP,
    value_deserializer=lambda x: json.loads(x.decode('utf-8'))
)

print(f"‚úÖ Subskrybent dzia≈Ça na topicu '{KAFKA_TOPIC}'...")

# +------------------------------------+
# |  FUNKCJE PRZE≈ÅADOWUJƒÑCE MODELE ML  |
# |     Proces przetwarzania danych    |
# +------------------------------------+

# --- Funkcja do sprawdzania i prze≈Çadowywania modelu Klasteryzacji ---
def cluster_model_check():
    save_log(f"subscriber_bikes", "info", f"Rozpoczynam sprawdzanie statusu modelu '{CLUSTER_MODEL_NAME}'.")
    print(f"üîÑ Sprawdzam status modelu '{CLUSTER_MODEL_NAME}'...")

    model_status = get_model_status(CLUSTER_MODEL_NAME)

    if model_status and model_status.is_new_model_available:
        print(f"üö® Nowa wersja modelu '{CLUSTER_MODEL_NAME}' dostƒôpna! Rozpoczynam prze≈Çadowanie...")
        save_log(f"subscriber_bikes", "info", f"Nowa wersja modelu '{CLUSTER_MODEL_NAME}' jest dostƒôpna. Przystƒôpujƒô do prze≈Çadowania.")

        # Prze≈Çadowanie modelu
        if bike_cluster_predictor.reload_model():
            print(f"‚úÖ Model '{CLUSTER_MODEL_NAME}' pomy≈õlnie prze≈Çadowany. Resetujƒô flagƒô w bazie danych.")
            save_log(f"subscriber_bikes", "info", f"Model '{CLUSTER_MODEL_NAME}' pomy≈õlnie prze≈Çadowany. Resetujƒô flagƒô w bazie danych.")
            # Aktualizacja flagi w bazie danych
            update_model_new_available_flag(CLUSTER_MODEL_NAME, False)
            print(f"‚úÖ Flaga 'is_new_model_available' dla '{CLUSTER_MODEL_NAME}' ustawiona na False.")
        else:
            print(f"‚ùå B≈ÇƒÖd podczas prze≈Çadowywania modelu '{CLUSTER_MODEL_NAME}'. Flaga nie zosta≈Ça zresetowana.")
            save_log(f"subscriber_bikes", "error", f"B≈ÇƒÖd podczas prze≈Çadowywania modelu '{CLUSTER_MODEL_NAME}'. Flaga nie zosta≈Ça zresetowana.")
    else:
        print(f"‚òëÔ∏è Model '{CLUSTER_MODEL_NAME}' aktualny (is_new_model_available={model_status.is_new_model_available if model_status else 'Brak wpisu'}).")
        if not model_status:
            save_log(f"subscriber_bikes", "warning", f"Brak wpisu dla modelu '{CLUSTER_MODEL_NAME}' w bazie danych ModelStatus.")

# --- Funkcja do sprawdzania i prze≈Çadowywania modelu Klasyfikacji A (Binarny) ---
def class_model_A_check():
    save_log(f"subscriber_bikes", "info", f"Rozpoczynam sprawdzanie statusu modelu '{CLASS_MODEL_A}'.")
    print(f"üîÑ Sprawdzam status modelu '{CLASS_MODEL_A}'...")

    model_status = get_model_status(CLASS_MODEL_A)

    if model_status and model_status.is_new_model_available:
        print(f"üö® Nowa wersja modelu '{CLASS_MODEL_A}' dostƒôpna! Rozpoczynam prze≈Çadowanie...")
        save_log(f"subscriber_bikes", "info", f"Nowa wersja modelu '{CLASS_MODEL_A}' jest dostƒôpna. Przystƒôpujƒô do prze≈Çadowania.")

        # Prze≈Çadowanie modelu
        if bike_binary_predictor.reload_model(): # Tutaj zmieniono na bike_binary_predictor
            print(f"‚úÖ Model '{CLASS_MODEL_A}' pomy≈õlnie prze≈Çadowany. Resetujƒô flagƒô w bazie danych.")
            save_log(f"subscriber_bikes", "info", f"Model '{CLASS_MODEL_A}' pomy≈õlnie prze≈Çadowany. Resetujƒô flagƒô w bazie danych.")
            # Aktualizacja flagi w bazie danych
            update_model_new_available_flag(CLASS_MODEL_A, False)
            print(f"‚úÖ Flaga 'is_new_model_available' dla '{CLASS_MODEL_A}' ustawiona na False.")
        else:
            print(f"‚ùå B≈ÇƒÖd podczas prze≈Çadowywania modelu '{CLASS_MODEL_A}'. Flaga nie zosta≈Ça zresetowana.")
            save_log(f"subscriber_bikes", "error", f"B≈ÇƒÖd podczas prze≈Çadowywania modelu '{CLASS_MODEL_A}'. Flaga nie zosta≈Ça zresetowana.")
    else:
        print(f"‚òëÔ∏è Model '{CLASS_MODEL_A}' aktualny (is_new_model_available={model_status.is_new_model_available if model_status else 'Brak wpisu'}).")
        if not model_status:
            save_log(f"subscriber_bikes", "warning", f"Brak wpisu dla modelu '{CLASS_MODEL_A}' w bazie danych ModelStatus.")

# --- Funkcja do sprawdzania i prze≈Çadowywania modelu Klasyfikacji B (Wieloklasowy) ---
def class_model_B_check():
    save_log(f"subscriber_bikes", "info", f"Rozpoczynam sprawdzanie statusu modelu '{CLASS_MODEL_B}'.")
    print(f"üîÑ Sprawdzam status modelu '{CLASS_MODEL_B}'...")

    model_status = get_model_status(CLASS_MODEL_B)

    if model_status and model_status.is_new_model_available:
        print(f"üö® Nowa wersja modelu '{CLASS_MODEL_B}' dostƒôpna! Rozpoczynam prze≈Çadowanie...")
        save_log(f"subscriber_bikes", "info", f"Nowa wersja modelu '{CLASS_MODEL_B}' jest dostƒôpna. Przystƒôpujƒô do prze≈Çadowania.")

        # Prze≈Çadowanie modelu
        if bike_multiclass_predictor.reload_model():
            print(f"‚úÖ Model '{CLASS_MODEL_B}' pomy≈õlnie prze≈Çadowany. Resetujƒô flagƒô w bazie danych.")
            save_log(f"subscriber_bikes", "info", f"Model '{CLASS_MODEL_B}' pomy≈õlnie prze≈Çadowany. Resetujƒô flagƒô w bazie danych.")
            # Aktualizacja flagi w bazie danych
            update_model_new_available_flag(CLASS_MODEL_B, False)
            print(f"‚úÖ Flaga 'is_new_model_available' dla '{CLASS_MODEL_B}' ustawiona na False.")
        else:
            print(f"‚ùå B≈ÇƒÖd podczas prze≈Çadowywania modelu '{CLASS_MODEL_B}'. Flaga nie zosta≈Ça zresetowana.")
            save_log(f"subscriber_bikes", "error", f"B≈ÇƒÖd podczas prze≈Çadowywania modelu '{CLASS_MODEL_B}'. Flaga nie zosta≈Ça zresetowana.")
    else:
        print(f"‚òëÔ∏è Model '{CLASS_MODEL_B}' aktualny (is_new_model_available={model_status.is_new_model_available if model_status else 'Brak wpisu'}).")
        if not model_status:
            save_log(f"subscriber_bikes", "warning", f"Brak wpisu dla modelu '{CLASS_MODEL_B}' w bazie danych ModelStatus.")

# --- Funkcja do sprawdzania i prze≈Çadowywania modelu Klasyfikacji C (Regresja) ---
def class_model_C_check():
    save_log(f"subscriber_bikes", "info", f"Rozpoczynam sprawdzanie statusu modelu '{CLASS_MODEL_C}'.")
    print(f"üîÑ Sprawdzam status modelu '{CLASS_MODEL_C}'...")

    model_status = get_model_status(CLASS_MODEL_C)

    if model_status and model_status.is_new_model_available:
        print(f"üö® Nowa wersja modelu '{CLASS_MODEL_C}' dostƒôpna! Rozpoczynam prze≈Çadowanie...")
        save_log(f"subscriber_bikes", "info", f"Nowa wersja modelu '{CLASS_MODEL_C}' jest dostƒôpna. Przystƒôpujƒô do prze≈Çadowania.")

        # Prze≈Çadowanie modelu
        if bike_regression_predictor.reload_model():
            print(f"‚úÖ Model '{CLASS_MODEL_C}' pomy≈õlnie prze≈Çadowany. Resetujƒô flagƒô w bazie danych.")
            save_log(f"subscriber_bikes", "info", f"Model '{CLASS_MODEL_C}' pomy≈õlnie prze≈Çadowany. Resetujƒô flagƒô w bazie danych.")
            # Aktualizacja flagi w bazie danych
            update_model_new_available_flag(CLASS_MODEL_C, False)
            print(f"‚úÖ Flaga 'is_new_model_available' dla '{CLASS_MODEL_C}' ustawiona na False.")
        else:
            print(f"‚ùå B≈ÇƒÖd podczas prze≈Çadowywania modelu '{CLASS_MODEL_C}'. Flaga nie zosta≈Ça zresetowana.")
            save_log(f"subscriber_bikes", "error", f"B≈ÇƒÖd podczas prze≈Çadowywania modelu '{CLASS_MODEL_C}'. Flaga nie zosta≈Ça zresetowana.")
    else:
        print(f"‚òëÔ∏è Model '{CLASS_MODEL_C}' aktualny (is_new_model_available={model_status.is_new_model_available if model_status else 'Brak wpisu'}).")
        if not model_status:
            save_log(f"subscriber_bikes", "warning", f"Brak wpisu dla modelu '{CLASS_MODEL_C}' w bazie danych ModelStatus.")

# +-------------------------------------+
# |       G≈Å√ìWNA CZƒò≈öƒÜ WYKONUJƒÑCA       |
# |      Proces przetwarzania danych    |
# +-------------------------------------+

try:
    for message in consumer:
        # --- Sprawdzenie modelu Klasteryzacji na poczƒÖtku ka≈ºdej iteracji pƒôtli ---
        cluster_model_check()
        class_model_A_check()
        class_model_B_check()
        class_model_C_check()

        data = message.value
        vehicle = data.pop("vehicle_types_available", {})
        data["bike_available"] = vehicle.get("bike", 0)
        data["ebike_available"] = vehicle.get("ebike", 0)

        print("üß† Odebrano wiadomo≈õƒá:")
        print(json.dumps(data, indent=2, ensure_ascii=False))

        # Wywo≈Çujemy funkcjƒô wzbogadzajƒÖcƒÖ dane bikes o dane ≈õrodowiskowe (environment)
        enriched = enrich_data_with_environment("subscriber_bikes", data)
        enriched = rename_keys(enriched)
        enriched = replace_nulls(enriched)

        if any(value is None for value in enriched.values()):
            print("‚ö†Ô∏è Wykryto warto≈õci None w danych po przetworzeniu. Pomijam dalsze przetwarzanie i przechodzƒô do nastƒôpnej wiadomo≈õci.")
            save_log("subscriber_bikes", "warning", "Wykryto warto≈õci None w danych po preprocessing. Pominiƒôto wiadomo≈õƒá.")
            continue

        print("üß†üß†üß† Wzbogacone dane:")
        print(json.dumps(enriched, indent=2, ensure_ascii=False))

        # +-------------------------------------+
        # |         CZƒò≈öƒÜ KLASTROWANIA          |
        # |     Proces przetwarzania danych     |
        # +-------------------------------------+

        cluster_id = bike_cluster_predictor.predict_cluster_from_dict(enriched)
        
        if cluster_id is not None:
            enriched['cluster_id'] = cluster_id
            enriched['cluster_prediction_success'] = True
            print(f"üéØ Przewidziano klaster: {cluster_id}")
        else:
            enriched['cluster_id'] = None
            enriched['cluster_prediction_success'] = False
            print("‚ö†Ô∏è Nie uda≈Ço siƒô przewidzieƒá klastra")

        print("üß†üß†üß†üß†üß†üß† Wzbogacone dane (z klastrem):")
        print(json.dumps(enriched, indent=2, ensure_ascii=False, default=str))

        # +-------------------------------------+
        # |         CZƒò≈öƒÜ KLASYFIKACJI          |
        # |     Proces przetwarzania danych     |
        # +-------------------------------------+

        # Predykcja binarna
        if bike_binary_predictor.is_loaded:
            binary_pred_result = bike_binary_predictor.predict(enriched)
            # Sprawdzamy, czy wynik jest krotkƒÖ o 3 elementach
            if isinstance(binary_pred_result, Tuple) and len(binary_pred_result) == 3:
                prediction_num, probabilities, prediction_label = binary_pred_result  # Prawid≈Çowe rozpakowanie
                enriched['bike_binary_prediction'] = prediction_num
                enriched['bike_binary_probabilities'] = probabilities
                enriched['bike_binary_prediction_success'] = True
                enriched['bike_binary_label'] = prediction_label  # Zapisujemy etykietƒô tekstowƒÖ
                print(f"üéØ Predykcja binarna dla rower√≥w: {prediction_num} ({enriched['bike_binary_label']}), Prawdopodobie≈Ñstwa: {probabilities}")
            else:
                enriched['bike_binary_prediction'] = None
                enriched['bike_binary_probabilities'] = None
                enriched['bike_binary_prediction_success'] = False
                enriched['bike_binary_label'] = None
                print(f"‚ö†Ô∏è B≈ÇƒÖd: Nieprawid≈Çowy wynik predykcji binarnej dla rower√≥w: {binary_pred_result}")
        else:
            enriched['bike_binary_prediction'] = None
            enriched['bike_binary_probabilities'] = None
            enriched['bike_binary_prediction_success'] = False
            enriched['bike_binary_label'] = None
            print(f"‚ö†Ô∏è Model {bike_binary_predictor.model_name} nie za≈Çadowany, pomijam predykcjƒô binarnƒÖ dla rower√≥w.")

        # Predykcja wieloklasowa
        if bike_multiclass_predictor.is_loaded:
            multiclass_pred_result = bike_multiclass_predictor.predict(enriched)
            # Sprawdzamy, czy wynik jest krotkƒÖ o 3 elementach
            if isinstance(multiclass_pred_result, Tuple) and len(multiclass_pred_result) == 3:
                prediction_num, probabilities, prediction_label = multiclass_pred_result  # Prawid≈Çowe rozpakowanie
                enriched['bike_multiclass_prediction'] = prediction_num
                enriched['bike_multiclass_probabilities'] = probabilities
                enriched['bike_multiclass_prediction_success'] = True
                enriched['bike_multiclass_label'] = prediction_label  # Zapisujemy etykietƒô tekstowƒÖ
                print(f"üéØ Predykcja wieloklasowa dla rower√≥w: {prediction_num} ({enriched['bike_multiclass_label']}), Prawdopodobie≈Ñstwa: {probabilities}")
            else:
                enriched['bike_multiclass_prediction'] = None
                enriched['bike_multiclass_probabilities'] = None
                enriched['bike_multiclass_prediction_success'] = False
                enriched['bike_multiclass_label'] = None
                print(f"‚ö†Ô∏è B≈ÇƒÖd: Nieprawid≈Çowy wynik predykcji wieloklasowej dla rower√≥w: {multiclass_pred_result}")
        else:
            enriched['bike_multiclass_prediction'] = None
            enriched['bike_multiclass_probabilities'] = None
            enriched['bike_multiclass_prediction_success'] = False
            enriched['bike_multiclass_label'] = None
            print(f"‚ö†Ô∏è Model {bike_multiclass_predictor.model_name} nie za≈Çadowany, pomijam predykcjƒô wieloklasowƒÖ dla rower√≥w.")

        # Predykcja regresji
        if bike_regression_predictor.is_loaded:
            regression_prediction = bike_regression_predictor.predict(enriched)
            # Sprawdzamy, czy wynik jest liczbƒÖ zmiennoprzecinkowƒÖ
            if isinstance(regression_prediction, float):
                # Zapisujemy oryginalnƒÖ predykcjƒô przed obciƒôciem
                enriched['bike_regression_prediction_original'] = regression_prediction
                # Obciƒôcie do 0, je≈õli jest ujemne
                clipped_prediction = max(0, regression_prediction)
                enriched['bike_regression_prediction'] = clipped_prediction
                enriched['bike_regression_prediction_success'] = True
                print(f"üéØ Predykcja regresji dla rower√≥w: {clipped_prediction:.2f} (oryginalna: {regression_prediction:.2f})")
                if regression_prediction < 0:
                    print("‚ö†Ô∏è UWAGA: Przewidywana liczba rower√≥w by≈Ça ujemna i zosta≈Ça obciƒôta do 0.")
            else:
                enriched['bike_regression_prediction'] = None
                enriched['bike_regression_prediction_success'] = False
                enriched['bike_regression_prediction_original'] = None
                print(f"‚ö†Ô∏è B≈ÇƒÖd: Nieprawid≈Çowy wynik predykcji regresji dla rower√≥w: {regression_prediction}")
        else:
            enriched['bike_regression_prediction'] = None
            enriched['bike_regression_prediction_success'] = False
            enriched['bike_regression_prediction_original'] = None
            print(f"‚ö†Ô∏è Model {bike_regression_predictor.model_name} nie za≈Çadowany, pomijam predykcjƒô regresji dla rower√≥w.")

        print("üî•üî•üî•üî•üî•üî• Wzbogacone dane (z klastrem i predykcjami klasyfikacji/regresji):")
        print(json.dumps(enriched, indent=2, ensure_ascii=False, default=str))

        # +-------------------------------------+
        # |         CZƒò≈öƒÜ EMBEDDINGOWA          |
        # |     Proces przetwarzania danych     |
        # +-------------------------------------+

        # --- Tworzenie zdania podsumowujƒÖcego ---
        summary_sentence = create_bike_summary_sentence(enriched)
        print(f"\nüìù Wygenerowane zdanie podsumowujƒÖce: {summary_sentence}")

        # +----------------------------------------+
        # |  ≈ÅƒÑCZENIE DANYCH I WYSY≈ÅANIE DO BAZY   |
        # |     Proces przetwarzania danych        |
        # +----------------------------------------+

        # Krok 1: Przygotowanie i wys≈Çanie danych dla bazy SQL
        final_data = prepare_sql_record_all_fields(enriched, summary_sentence)
        print("\nüìä Dane przygotowane dla bazy SQL (wszystkie pola zachowane):")
        print(json.dumps(final_data, indent=2, ensure_ascii=False, default=str))

        # Krok 2: Przygotowanie danych dla bazy wektorowej
        data = prepare_vector_db_record_all_bike_fields(enriched)

        if summary_sentence:
            print("\nüóÉÔ∏è Struktura przygotowana dla AnythingLLM (tekst i metadane):")
            printable_anythingllm_payload = data.copy()
            print(f"textContent_preview='{summary_sentence[:100]}...', metadata keys={list(printable_anythingllm_payload.keys())}")
            print(f"Pe≈Çne metadane: {json.dumps(printable_anythingllm_payload, indent=2, ensure_ascii=False, default=str)}")
            
            save_log("subscriber_bikes", "info", "Dane przygotowane dla AnythingLLM.") # Zmieniono log

            print("\nüöÄ Wysy≈Çanie danych do AnythingLLM...")
            add_response = add_raw_bike_text_to_anythingllm(
                ANYTHINGLLM_WORKSPACE_SLUG,
                summary_sentence,
                data
            )
            print("Odpowied≈∫ z AnythingLLM:", add_response)
            if add_response.get("success"):
                save_bike_data_to_base(final_data)
                save_log("subscriber_bikes", "info", f"Tekst dodany do AnythingLLM dla workspace'u {ANYTHINGLLM_WORKSPACE_SLUG}.") # Zmieniono log
            else:
                save_log("subscriber_bikes", "error", f"B≈ÇƒÖd podczas dodawania tekstu do AnythingLLM: {add_response.get('message')}")
        else:
            save_log("subscriber_bikes", "error", "Brak summary_sentence, nie wys≈Çano danych do AnythingLLM.")

except KeyboardInterrupt:
    print("‚õî Subskrybent zatrzymany rƒôcznie (Ctrl+C).")
    save_log("subscriber_bikes", "info", "Subskrybent zatrzymany rƒôcznie.")
except Exception as e:
    print(f"‚ùå B≈ÇƒÖd krytyczny subskrybenta: {str(e)}")
    save_log("subscriber_bikes", "error", f"B≈ÇƒÖd subskrybenta: {str(e)}")
finally:
    consumer.close()
    print("üßπ Po≈ÇƒÖczenie z Kafka zako≈Ñczone.")
